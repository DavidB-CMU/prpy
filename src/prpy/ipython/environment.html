<!--
Copyright (c) 2015, Carnegie Mellon University
All rights reserved.
Authors: Pras Velagapudi <pkv@cs.cmu.edu>
-->

<!-- Create main element to store the display object. -->
<div id="three-js-content"></div>

<!-- Implement actual code to render the environment. -->
<script type="text/javascript">

// Load necessary imports.
require.config({
    paths: {
        THREE: "https://cdnjs.cloudflare.com/ajax/libs/three.js/r72/three.min",
        Detector: "http://threejs.org/examples/js/Detector",
        OrbitControls: "http://threejs.org/examples/js/controls/OrbitControls"
    },
    shim: {
        THREE: { exports: 'THREE' },
        Detector: { exports: 'Detector' },
        OrbitControls: { exports: 'OrbitControls' }
    }
});

require(["THREE", "Detector", "OrbitControls"], function(THREE, Detector, OrbitControls) {
    'use strict';

    // Check for WebGL compatibility.
    if (!Detector.webgl)
        Detector.addGetWebGLMessage();

    // Global variables for rendering.
    var container, scene, camera, renderer, controls;

    // Create Three.js scene to render environment.
    function init() 
    {
        // SCENE
        scene = new THREE.Scene();

        // CAMERA
        var SCREEN_WIDTH = window.innerWidth,
            SCREEN_HEIGHT = window.innerHeight;
        var VIEW_ANGLE = 45,
            ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT,
            NEAR = 0.1, FAR = 20000;
        camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
        scene.add(camera);
        camera.position.set(0.0, 2.0, 2.0);
        camera.up.set(0.0, 0.0, 1.0);
        camera.lookAt(scene.position);  

        // RENDERER
        renderer = new THREE.WebGLRenderer({ antialias:true });
        renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        container = document.getElementById('three-js-content');
        container.appendChild(renderer.domElement);

        // CONTROLS
        controls = new THREE.OrbitControls(camera, renderer.domElement);

        // LIGHT
        var light = new THREE.PointLight(0xffffff);
        light.position.set(1.0, 1.0, 2.0);
        scene.add(light);

        var ambient = new THREE.AmbientLight(0x808080);
        ambient.position.set(1.0, 1.0, 2.0);
        scene.add(ambient);

        {% for scene in scenes -%}
        // SCENES "{{ scene.name }}"
        var scenes = {}
        {
            var scene = new THREE.Object3D();
            {% for mesh in scene.meshes -%}
            {
                var geometry = new THREE.BufferGeometry();
                var vertices = new Float32Array({{ mesh.vertices }});
                geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));

                var indices = new Uint16Array({{ mesh.indices }});
                geometry.setIndex(new THREE.BufferAttribute(indices, 1));

                var mesh = new THREE.Mesh(geometry, material);
                // mesh.position.set({{ mesh.position | join(', ') }});
                // mesh.quaternion.set({{ mesh.quaternion | join(', ') }});

                scene.add(mesh);
            }
            {% endfor %}
            scenes['{{ scene.name }}'] = scene
        }
        {% endfor %}

        {% for body in bodies -%}
        {% for link in body.links -%}
        // LINK "{{ body.name }} - {{ link.name }}"
        {
            var link = new THREE.Object3D();
            link.name = "{{ body.name }} - {{ link.name }}";
            link.position.set({{ link.position | join(', ') }});
            link.quaternion.set({{ link.quaternion | join(', ') }});

            {% for geom in link.geometries -%}
            // GEOMETRY
            {
                {% if not geom.render.filename -%}
                // COLLISION
                // Type: {{ geom.collision.type }}
                var material = new THREE.MeshLambertMaterial({
                    color: new THREE.Color({{ geom.color.diffuse | join(', ') }}),
                    emissive: new THREE.Color({{ geom.color.ambient | join(', ') }}),
                    opacity: {{ geom.color.opacity }},
                    transparent: {% if geom.color.isTransparent %}true{% else %}false{% endif %}
                });

                {% if geom.collision.type == 'Box' -%}
                var geometry = new THREE.BoxGeometry(
                    {{ geom.collision.extents | join(', ') }}
                );
                {% elif geom.collision.type == 'Cylinder' -%}
                var geometry = new THREE.CylinderGeometry(
                    {{ geom.collision.radius }}, {{ geom.collision.radius }},
                    {{ geom.collision.height }}, 32
                );
                {% elif geom.collision.type == 'Sphere' -%}
                var geometry = new THREE.SphereGeometry(
                    {{ geom.collision.radius }}, 32, 32
                );
                {% elif geom.collision.type == 'Trimesh' -%}
                var geometry = new THREE.BufferGeometry();
                var vertices = new Float32Array({{ geom.collision.vertices }});
                geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));

                var indices = new Uint16Array({{ geom.collision.indices }});
                geometry.setIndex(new THREE.BufferAttribute(indices, 1));
                {%- endif -%}

                var mesh = new THREE.Mesh(geometry, material);
                mesh.position.set({{ geom.position | join(', ') }});
                mesh.quaternion.set({{ geom.quaternion | join(', ') }});

                link.add(mesh);
                {%- else %}
                // RENDER
                if ('{{ geom.render.filename }}' in scenes) {
                    var mesh = scenes['{{ geom.render.filename }}'].clone()
                    link.add(mesh);
                }
                {%- endif %}
            }
            {% endfor %}
            scene.add(link);
        }
        {% endfor %}
        {% endfor %}
    }

    // Perform update and schedule next update.
    function animate()
    {
        requestAnimationFrame(animate);
        render();       
        update();
    }

    // Process events in scene.
    function update()
    {
        controls.update();
    }

    // Render current version of scene.
    function render() 
    {
        renderer.render(scene, camera);
    }

    // Startup and run rendering loop.
    init();
    animate();
});
</script>
